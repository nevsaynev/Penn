//////////////////////////////////////////////////////////////////////////////
// Model: dpp.qm
// File:  ./bsp.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//////////////////////////////////////////////////////////////////////////////
// @(/3/1) ...................................................................
#include "qp_port.h"
#include "dpp.h"
#include "bsp.h"
#include "Arduino.h"  // Arduino include file

Q_DEFINE_THIS_FILE

//#define SAVE_POWER

#define USER_LED_ON()      (PORTB |= (1 << (5)))
#define USER_LED_OFF()     (PORTB &= ~(1 << (5)))
#define USER_LED_TOGGLE()  (PORTB ^= (1 << (5)))

#define TICK_DIVIDER       ((F_CPU / BSP_TICKS_PER_SEC / 1024) - 1)

#if TICK_DIVIDER > 255
#   error BSP_TICKS_PER_SEC too small
#elif TICK_DIVIDER < 2
#   error BSP_TICKS_PER_SEC too large
#endif

// local variables -----------------------------------------------------------
static uint32_t l_rnd;                                          // random seed

#ifdef Q_SPY
uint8_t l_TIMER2_COMPA;
#endif


// ISRs ----------------------------------------------------------------------
ISR(TIMER2_COMPA_vect) {
    // No need to clear the interrupt source since the Timer2 compare
    // interrupt is automatically cleard in hardware when the ISR runs.

    QK_ISR_ENTRY();                         // infrom QK about entering an ISR

    QF::TICK(&l_TIMER2_COMPA);                // process all armed time events

    if (Serial.available() > 0) {
        switch (Serial.read()) {                     // read the incoming byte
            case 'p':
            case 'P':
                QF::PUBLISH(Q_NEW(QEvt, PAUSE_SIG), &l_TIMER2_COMPA);
                break;
        }
    }

    QK_ISR_EXIT();                           // infrom QK about exiting an ISR
}

//............................................................................
void QF::onStartup(void) {
          // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking
    TCCR2A = ((1 << WGM21) | (0 << WGM20));
    TCCR2B = (( 1 << CS22 ) | ( 1 << CS21 ) | ( 1 << CS20 ));        // 1/2^10
    ASSR &= ~(1<<AS2);
    TIMSK2 = (1 << OCIE2A);                 // Enable TIMER2 compare Interrupt
    TCNT2 = 0;
    OCR2A = TICK_DIVIDER;     // must be loaded last for Atmega168 and friends
}
//............................................................................
void QF::onCleanup(void) {
}
//............................................................................
void QK::onIdle() {

    QF_INT_DISABLE();
    USER_LED_ON();     // toggle the User LED on Arduino on and off, see NOTE1
    USER_LED_OFF();
    QF_INT_ENABLE();

#ifdef SAVE_POWER

    SMCR = (0 << SM0) | (1 << SE);  // idle sleep mode, adjust to your project

    __asm__ __volatile__ ("sleep" "\n\t" :: );

    SMCR = 0;                                              // clear the SE bit

#endif
}
//............................................................................
void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
    QF_INT_DISABLE();                                // disable all interrupts
    USER_LED_ON();                                  // User LED permanently ON
    asm volatile ("jmp 0x0000");    // perform a software reset of the Arduino
}

//............................................................................
void BSP_init(void) {
    DDRB  = 0xFF;                     // All PORTB pins are outputs (user LED)
    PORTB = 0x00;                                        // drive all pins low

    Serial.begin(115200);
    Serial.println("Start");

    if (QS_INIT((void *)0) == 0) {       // initialize the QS software tracing
        Q_ERROR();
    }
    QS_RESET();
    QS_OBJ_DICTIONARY(&l_SysTick_Handler);

    BSP_randomSeed(1234U);
}
//............................................................................
void BSP_terminate(int16_t result) {
    (void)result;
}
//............................................................................
void BSP_displayPaused(uint8_t paused) {
    if (paused) {
        Serial.println(F("Paused ON"));
    }
    else {
        Serial.println(F("Paused OFF"));
    }
}
//............................................................................
void BSP_displayPhilStat(uint8_t n, char_t const *stat) {
    Serial.print(F("Philosopher "));
    Serial.print( n, DEC);
    Serial.print(F(" "));
    Serial.println(stat);
}
//............................................................................
uint32_t BSP_random(void) {     // a very cheap pseudo-random-number generator
    // "Super-Duper" Linear Congruential Generator (LCG)
    // LCG(2^32, 3*7*11*13*23, 0, seed)
    //
    l_rnd = l_rnd * (3*7*11*13*23);
    return l_rnd >> 8;
}
//............................................................................
void BSP_randomSeed(uint32_t seed) {
    l_rnd = seed;
}

//////////////////////////////////////////////////////////////////////////////
// NOTE1:
// The Arduino's User LED is used to visualize the idle loop activity.
// The brightness of the LED is proportional to the frequency of invcations
// of the idle loop. Please note that the LED is toggled with interrupts
// locked, so no interrupt execution time contributes to the brightness of
// the User LED.
//


